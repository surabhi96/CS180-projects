<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Image Warping and Mosaicing - Part I</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
    h1, h2, h3 { margin-top: 40px; }
    img { max-width: 400px; margin: 10px; border: 1px solid #ccc; }
    .section { margin-bottom: 60px; }
  </style>
</head>
<body>

<h1>Image Warping and Mosaicing - Part I</h1>
<!-- <p>This project explores 2D convolution, filtering, frequencies, and multi-resolution blending. 
All results shown below were implemented from scratch in Python.</p> -->

<div class="section">
<h2>A.1: Shoot the Pictures</h2>

<p>
  Images are taken from the courtyard of a building complex. The images are good candidates for creating a mosaic as they 
  naturally contain a lot of corners due to vertical and horizontal line intersections. 
</p>

<img src="data/left.jpeg" alt="left image">
<img src="data/middle.jpeg" alt="middle image">
<img src="data/right.jpeg" alt="right image">

<h3>A.2: Recover Homographies</h3>
<p>To compute the homography between two images, the correspondences are first marked manually and stored in a txt file.</p>
<img src="results/corresps_left.jpeg" alt="Gradient magnitude">
<img src="results/corresps_right.jpeg" alt="Gradient magnitude">
<p>Once 1-1 point to point correspondences are established, homography is computed via least squares. 
  Below is the code snippet along with comments that compute the homography matrix.</p>
<h3>Compute homography</h3>
<pre><code>
  def compute_homography(pts1_n, pts2_n):
    A = []
    # Populate the A matrix to form Ah = 0 
    for (x, y), (u, v) in zip(pts1_n, pts2_n):
        A.append([x, y, 1, 0, 0, 0, -u*x, -u*y, -u])
        A.append([0, 0, 0, x, y, 1, -v*x, -v*y, -v])
    A = np.array(A)
    # Compute the SVD of A
    U, S, Vt = np.linalg.svd(A)
    # Last column of V or last row of V transpose is the least squares solution to Ah = 0
    H = Vt[-1,:].reshape(3,3)
    # The scale is factored out from the homography matrix
    H /= H[-1,-1]
    return H
</code></pre>
<h4>Estimated homography between left and mid image</h4>
<pre><code>
 [[ 1.69867416e+00  4.05641368e-02 -1.20704547e+03]
 [ 2.37761687e-01  1.43178785e+00 -5.77526132e+02]
 [ 1.65231738e-04  2.09763667e-05  1.00000000e+00]]
</code></pre>
<h5>Estimated homography between right and mid image</h5>
<pre><code>
Estimated homography between right and mid image:
 [[ 5.07890256e-01  4.81447356e-03  8.33327316e+02]
 [-2.01050693e-01  7.71031301e-01  3.65449108e+02]
 [-1.21041275e-04 -4.04771370e-06  1.00000000e+00]]
</code></pre>
<h6>A.3: Warp the Images</h6>
  <p>In this section, a planar object in the projective plane i.e. image plane is transformed to a
    front facing plane with dimensions of choice. Inverse Warping is used to avoid holes and two 
    different techniques are tested for interpolation.  </p>
    <img src="results/input_1_annotation.jpeg" alt="Input image correspondence" width="600">
    <img src="results/A_3_eg1.jpeg" alt="Comparing nn with bilinear interp" width="600">
    <table border="1" cellspacing="0" cellpadding="5" style="margin-top:10px; border-collapse:collapse; text-align:center;">
      <tr style="background-color:#f0f0f0;">
        <th>Interpolation Method</th>
        <th>Visual Quality</th>
        <th>Computation Time (ms)</th>
      </tr>
      <tr>
        <td>Nearest Neighbor</td>
        <td>Pixelated edges, blocky artifacts</td>
        <td>12.5 (Faster)</td>
      </tr>
      <tr>
        <td>Bilinear Interpolation</td>
        <td>Smoother transitions, better continuity</td>
        <td>18.3 (Slower)</td>
      </tr>
    </table>
<h6>A.3: Warp the Images</h6>
<h7>A.4: Blend the Images into a Mosaic</div>h7>
</div>

<!-- <div class="section">
  <h2>Part 2: Fun with Frequencies!</h2>

  <h3>Part 2.1: Image Sharpening</h3>
  <p>Implemented unsharp masking to sharpen images by enhancing their high frequencies.</p>
  <img src="results/taj.jpeg" alt="Taj sharpened">
  <p>
  To evaluate the sharpening approach, the original image was blurred with a Gaussian filter, 
  and then sharpened again. The sharpening step enhances the blurred image slightly, but it cannot fully recover 
  the original fine details that were lost during blurring. Shapening only amplifies the edges and sometimes might .
</p>
<div>
    <img src="data/nutmeg.jpg" alt="DoG filters" width="600">
    <figcaption>Original</figcaption>
  </div>
  <div>
    <img src="results/nutmeg_sharpen.jpeg" alt="DoG filtered image" width="1000">
    <figcaption>Sharpened (after blur)</figcaption>
  </div>
  
  <h3>Part 2.2: Hybrid Images</h3>
  <p>By combining low frequencies of one image and high frequencies of another, hybrid images were created. 
    The factor that helped the most in creating a good high and low frequency image was setting different sigma 
    values (for convolution) to obtain each of these images Additionally, having different alpha values for the low 
    and high frequency image was helpful too. For the first image, sigma_low_freq = 7, sigma_high_freq = 5; 
    For second image, sigma_low_freq = 2, sigma_high_freq = 2. Additionally, the frequency domain of the images are shown. 
    One can observe that the low frequency images contain the lower frequencies while the high frequency image contains higher frequencies.
    The occasional high frequency elements in the low frequency image spectrum could be a result of the black borders that are obtained
    from running the image alignment procedure. </p>
  <div>
    <img src="results/hybrid1.jpeg" alt="DoG filters" width="600">
  </div>
  <div>
    <img src="results/hybrid2.jpeg" alt="DoG filtered image" width="1000">
  </div>
  <div>
    <img src="results/freq1.jpeg" alt="DoG filters" width="600">
  </div>
  <div>
    <img src="results/freq2.jpeg" alt="DoG filtered image" width="1000">
  </div>

  <h3>Part 2.3: Gaussian and Laplacian Stacks</h3>
  <p>Implemented Gaussian and Laplacian stacks for multi-resolution blending.</p>
   <div>
    <img src="results/pyr1.jpeg" alt="DoG filters" width="600">
  </div>
  <div>
    <img src="results/pyr2.jpeg" alt="DoG filtered image" width="1000">
  </div>

  <h3>Part 2.4: Multiresolution Blending (The Oraple)</h3>
  <p>Blended two different kinds of pots seamlessly using Laplacian stacks and Gaussian stacks. </p>
  <img src="results/blend.jpeg" alt="Oraple result">
</div> -->

</body>
</html>
